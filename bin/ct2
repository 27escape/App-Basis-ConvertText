#!/usr/bin/env perl

=head1 NAME

ct2

=head1 DESCRIPTION

Convert my modified version of markdown into various document formats

this will create a ~/.ct2 directory and add some files to it, such as your
basic config and the initial templates

    $ ct2 --help

    Syntax: ct2 [options] filename

    About:  Convert my modified markdown text files into other formats, by
    default will create HTML in same directory as the input file, will only
    process .md or .mdown files.
    If there is no output option used the output will be to file of same name
    as the input filename but  with an extension (if provided) from the
    document, use format: keyword (pdf html doc).

    [options]
        -h, -?, --help        Show help
        -c, --clean           Clean up the cache before use
        -e, --embed           Embed images into HTML, do not use this if
            converting to doc/odt
        -o, --output          Filename to store the output as, extension will
            control conversion
        -p, --prince          Convert to PDF using princexml, can handle
            embedded images
        -t, --template        name of template to use
        -v, --verbose         verbose mode
        -w, --wkhtmltopdf     Convert to PDF using wkhtmltopdf, can handle
            embedded images
        -m, --commonmark      use CommonMark rather than pandoc for markdown processing

=head1 AUTHOR

 kevin mulholland, moodfarm@cpan.org

=cut

use v5.10 ;
use strict ;
use warnings ;
use Data::Printer ;
use POSIX qw(strftime) ;
use Try::Tiny ;
use Path::Tiny ;
use App::Basis ;
use App::Basis::Config ;
use App::Basis::ConvertText2 ;
use utf8::all ;

# -----------------------------------------------------------------------------

# if the user does not specify we will convert to pdf
use constant DEFAULT_FILE_FORMAT => 'pdf' ;

# -----------------------------------------------------------------------------

my $MARKUP_DIR = "$ENV{HOME}/." . get_program() ;
$MARKUP_DIR = $ENV{MARKUP_DIR} if ( $ENV{MARKUP_DIR} ) ;

# my $CACHE_DIR = "/tmp/" . getpwuid($>) . "/cache";
my $CACHE_DIR = "$ENV{HOME}/.cache/" ;

my $TEMPLATE = <<EOD;
<!DOCTYPE html>
<html>
    <head>
        <title>%TITLE%</title>
        <meta name="Created" content="%DATE%" />
        <meta name="Author" content="%AUTHOR%" />
        <meta name="Copyright" content="%COPYRIGHT%" />
        <meta name="summary" content="%SUMMARY%" />
        <meta name="keywords" content="%KEYWORDS%" />
        <meta name="revision" content="%REVISION%" />
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

        <link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
        <link href='http://fonts.googleapis.com/css?family=Cousine' rel='stylesheet' type='text/css'>

        %GOOGLE_FONT%

        %JAVASCRIPT%

        <style type='text/css'>
            \@page { 
                size: %PAGE_SIZE% %ORIENTATION% ; 
                margin: 90pt 30pt 40pt 30pt ;
                \@top { margin: -10pt 0pt 0pt -90pt ; }
                \@bottom-right { content: counter(page) ;}
            }
            \@page landscape {
                    prince-rotate-body: 270deg;
            }
            %CSS%

            /* tables */
            table.footer { font-size: 10px; width: 100%;}
            table.footer td.commercial { 
                font-weight: bold; 
                font-size: 12px;
                text-align: center;
            }
        </style>
    </head>
    <body>
        <h1>%TITLE%</h1>
        <!-- uncomment this if you need a Table of Contents -->
        <!-- <div id='toc' >
            %TOC%
        </div> -->

        %_CONTENTS_%

        <table class='footer' width='100%'>
            <tr><td>(c) %COPYRIGHT%</td><td align='right'>%DATE%</td>
        </table>
    </body>
</html>
EOD

# -----------------------------------------------------------------------------

sub create_defaults
{
    my ( $dir, $verbose ) = @_ ;
    my $default = "$dir/templates/default" ;
    my ( $r, $o, $e ) ;

    die "dir option required" if ( !$dir ) ;

    if ( !-d $default ) {

        # create the defaults if they do not exist
        try { path($default)->mkpath } catch {} ;
        msg_exit("Could not create default templates dir in $dir")
            if ( !-d $default ) ;
    }

    # create HTML template
    if ( !-f "$default/template.html" ) {
        path("$default/template.html")->spew_utf8($TEMPLATE) ;
        say "Created default template in '$default/template.html'" ;

    }

    my $config = App::Basis::Config->new( filename => "$default/config" ) ;

    # if there is no data in the config then lets create some
    if ( !$config->has_data() ) {
        $config->set( '/page/size',        'A4' ) ;
        $config->set( '/page/orientation', 'Portrait' ) ;
        my $author = getpwuid($>) ;
        $config->set( '/author',    $author ) ;
        $config->set( '/copyright', "Property of $author 2014" ) ;
        $config->store() ;
        say "created default config in '$default/config'" ;
    }
}

# -----------------------------------------------------------------------------

sub read_settings
{
    my ( $template, $dir ) = @_ ;
    my %settings ;

    die "dir option required" if ( !$dir ) ;

    $template ||= 'default' ;
    $template =~ s/\v//g ;
    my $templatedir = "$dir/templates/$template" ;
    if ( !-d $templatedir ) {
        debug( "INFO",
            "Template '$template' does not exist, using default" ) ;
        $templatedir = "$dir/templates/default" ;
    }
    $settings{config}
        = App::Basis::Config->new( filename => "$templatedir/config" ) ;

    $settings{template}     = $template ;
    $settings{template_dir} = $templatedir ;
    $settings{template}     = path("$templatedir/template.html")->slurp_utf8 ;

    return \%settings ;
}

# -----------------------------------------------------------------------------
# main

my %opt = init_app(
    help_text =>
        "Convert my modified markdown text files into other formats, by 
    default will create HTML in same directory as the input file, will only 
    process .md or .mdown files. 
    If there is no output option used the output will be to file of same name 
    as the input filename but with an extension (if provided) from the
    document, use format: keyword (pdf html doc).",
    help_cmdline => "filename",
    options      => {
        'clean|c' => 'Clean up the cache before use',
        'embed|e' =>
            'Embed images into HTML, do not use this if converting to doc/odt',
        'output|o=s' => {
            desc =>
                'Filename to store the output as, extension will control conversion',
            default => "",
        },
        'prince|p' =>
            'Convert to PDF using princexml, can handle embedded images',
        'template|t=s' => 'name of template to use',
        'templates'    => 'list available templates',
        'wkhtmltopdf|w' =>
            'Convert to PDF using wkhtmltopdf, can handle embedded images',
        'verbose|v' => 'verbose mode',
        'commonmark|m' =>
            'use commonMark instead of pandoc for markdown processing',
    }
) ;

show_usage("You cannot use both prince and wkhtmltopdf options")
    if ( $opt{prince} && $opt{wkhtmltopdf} ) ;

$opt{config_dir} ||= $MARKUP_DIR ;
create_defaults( $opt{config_dir} ) ;

# get list of installed templates
if ( $opt{templates} ) {
    my @templates ;
    my $iter = path("$opt{config_dir}/templates")->iterator() ;

    while ( my $path = $iter->() ) {
        my $d = $path->stringify ;
        if ( -d $d && -f "$d/template.html" ) {
            push @templates, $path->basename ;
        }
    }

    msg_exit( "Templates:\n    " . join( "\n    ", sort @templates ) ) ;
}

$opt{filename} = $ARGV[0] ;
$opt{filename} =~ s/^~/$ENV{HOME}/ if ( $opt{filename} ) ;

if (!$opt{filename}
    || ( $opt{filename} ne '-'
        && !( -f $opt{filename} && $opt{filename} =~ /\.md$|\.mdown$/i ) )
    ) {
    warn "Bad filename '$opt{filename}'" if( $opt{filename}) ;
    show_usage("filename must exist and be .md (or .mdown") ;
}

my ( $story, $basedir ) ;
if ( $opt{filename} eq '-' ) {
    $story = do { local $/ ; <STDIN> } ;
    $basedir = Path::Tiny->cwd ;
} else {
    $story   = path( $opt{filename} )->slurp_utf8 ;
    $basedir = path( $opt{filename} )->dirname ;
}

show_usage("Bad markup file $opt{filename}") if ( !$story ) ;

# anything in the replace hash will get replaced in the final document
my $replace = {

# '%TITLE%'   => '',    # this comes from the first markdown level 1 header
# '%DATE%' => strftime( "%Y-%m-%d", gmtime() ),    # :date in document overrides
# '%COPYRIGHT%'   => $settings->{config}->get("copyright")        || '',    # :copyright in document overrides
# '%AUTHOR%'      => $settings->{config}->get("author")           || '',    # :author in document overrides
# '%PAGE_SIZE%'   => $settings->{config}->get("page/size")        || '',
# '%ORIENTATION%' => $settings->{config}->get("page/orientation") || '',
# '%KEYWORDS%' => '',   # get from document :keywords or :tags
# '%SUMMARY%' => '',   # get from document :summary
# '%REVISION%' => '',   # get from document :revision
} ;

# get any template from the stop of the story
my $settings ;
my ($template) = ( $story =~ /^template:\s?(.*?)$/sm ) ;

# document template overwritten by the command line option
$template = $opt{template} if ( $opt{template} ) ;
$settings = read_settings( $template, $opt{config_dir} ) ;

# add in template defaults if needed
$replace->{DATE} ||= strftime( "%Y-%m-%d", gmtime() ) ;
$replace->{COPYRIGHT}   ||= $settings->{config}->get("copyright") ;
$replace->{AUTHOR}      ||= $settings->{config}->get("author") ;
$replace->{PAGE_SIZE}   ||= $settings->{config}->get("page/size") ;
$replace->{ORIENTATION} ||= $settings->{config}->get("page/orientation") ;
$replace->{SUBTITLE}    ||= $settings->{config}->get("subtitle") ;

my $format = App::Basis::ConvertText2->new(
    name      => get_program(),
    basedir   => $basedir,
    use_cache => 1,
    cache_dir => $CACHE_DIR,
    template  => $settings->{template},
    replace   => $replace,
    verbose   => $opt{verbose},
    embed     => $opt{embed},
) ;
$format->clean_cache() if ( $opt{clean} ) ;

# be in the same dir as the input file in case there are an files in plugins
# that act on relative paths
my $current = Path::Tiny->cwd ;
chdir($basedir) ;

my $data = $format->parse( $story, $opt{commonmark} ) ;

# decide on output filename from any format keyword
# all the keywords are in UPPER-CASE
my $keywords = $format->replace ;

$keywords->{FORMAT} ||= DEFAULT_FILE_FORMAT ;

if ( $opt{output} ) {

    # strip quotes from output name
    $opt{output} =~ s/^["'](.*?)["'"]/$1/ ;
}

if ( !$opt{output} ) {

    # same name as input
    $opt{output} = $opt{filename} ;

    # change extension and add in the version or the date
    my $postfix = "" ;
    if ( $keywords->{VERSION} ) {
        $postfix = "-v$keywords->{VERSION}" ;
    } elsif ( $keywords->{DATE} ) {
        my $d = $keywords->{DATE} ;
        $d =~ s/\s/-/g ;
        # add to end of path if the path does not already have it
        $postfix = "-$d" if ( $opt{output} !~ /$d/ ) ;
    }
    $postfix .= ".$keywords->{FORMAT}" ;
    $opt{output} =~ s/\.md$|\.mdown$/$postfix/i ;
} elsif ( -d $opt{output} ) {

    # we can create the same file name in the required directory
    # append same name as input
    $opt{output} .= "/" . path( $opt{filename} )->basename ;

    # change extension and add in the version
    my $postfix = "" ;
    if ( $keywords->{VERSION} ) {
        $postfix = "-v$keywords->{VERSION}" ;
    }
    $postfix .= ".$keywords->{FORMAT}" ;
    $opt{output} =~ s/\.md$|\.mdown$/$postfix/i ;
}

if ( $opt{output} ) {
    my $pdfconvertor ;

    if ( $opt{prince} ) {
        $pdfconvertor = 'prince' ;
    } elsif ( $opt{wkhtmltopdf} ) {
        $pdfconvertor = 'wkhtmltopdf' ;
    }

    my $status = $format->save_to_file( $opt{output}, $pdfconvertor ) ;

    if ( $opt{verbose} && $status ) {
        say $opt{output} ;
    } elsif ( !$status ) {
        say STDERR "Failed to create $opt{output}" ;
    }
} else {
    say STDERR
        "Ignoring $opt{filename}, could not determine a filename to output to, no :format option in file?"
        ;
}

# return to where we came from
chdir($current) ;
